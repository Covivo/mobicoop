<template>
  <v-form :ref="name">
    <v-autocomplete
      v-model="address"
      :loading="isLoading"
      :items="items"
      :label="label + (required ? ' *' : '')"
      :hint="hint"
      :search-input.sync="search"
      hide-no-data
      clearable
      item-text="selectedDisplayedLabel"
      item-value="key"
      color="primary"
      return-object
      no-filter
      persistent-hint
      :required="required"
      :rules="geoRules"
      :disabled="disabled"
      @change="changedAddress()"
    >
      <!-- template for selected item  -->
      <template v-slot:selection="data">
        <template>
          {{ data.item.selectedDisplayedLabel }}
        </template>
      </template>
      <!-- template for list items  -->
      <template v-slot:item="data">
        <template v-if="typeof data.item !== 'object'">
          <v-list-item-content v-text="data.item" />
        </template>
        <template v-else>
          <v-list>
            <v-list-item>
              <v-list-item-avatar v-if="displayIcon">
                <v-avatar size="36">
                  <v-img
                    :src="data.item.icon"
                    contain
                  />
                </v-avatar>
              </v-list-item-avatar>
              <v-list-item-content>
                <v-list-item-title v-html="data.item.displayedLabel" />
                <v-list-item-subtitle v-html="data.item.displayedSecondLabel" />
              </v-list-item-content>
            </v-list-item>
          </v-list>
        </template>
      </template>
    </v-autocomplete>
  </v-form>
</template>

<script>
import axios from "axios";
import debounce from "lodash/debounce";
import merge from "lodash/merge";

import Translations from "@translations/components/utilities/GeoComplete.json";
import TranslationsClient from "@clientTranslations/components/utilities/GeoComplete.json";

let TranslationsMerged = merge(Translations, TranslationsClient);

const defaultString = {
  type: String,
  default: null
};
export default {
  i18n: {
    messages: TranslationsMerged
  },
  props: {
    url: defaultString,
    label: defaultString,
    token: defaultString,
    disabled: {
      type: Boolean,
      default: false
    },
    displayNameInSelected: {
      type: Boolean,
      default: true
    },
    displayIcon: {
      type: Boolean,
      default: true
    },
    displayRegion: {
      type: Boolean,
      default: true
    },
    hint: defaultString,
    required:  {
      type: Boolean,
      default: false
    },
    name: defaultString,
    initAddress: {
      type: Object,
      default: null
    }
  },
  data() {
    return {
      entries: [],
      isLoading: false,
      search: null,
      address: null,
      filter: null,
      cancelSource: null,
    };
  },
  computed: {
    items() {
      return this.entries;
    },
    geoRules() {
      if (this.required) {
        return [
          v => !!v || this.$t('required')
        ];
      }
      return [];
    }
  },
  watch: {
    search(val) {
      if (val) {
        if (val.length > 2) {
          val && val !== this.address && this.getAsyncData(val);
        }
      }
    },
    initAddress: {
      immediate: true,
      handler(newVal, oldVal) {
        this.address = this.initAddress;
        this.entries = [];
        if (this.address) {
          this.address.key = '0';
          this.address.displayedLabel = `${this.address.displayLabel[0]}`;
          this.address.displayedSecondLabel = `${this.address.displayLabel[1]}`;
          if (this.address.home) {
            this.address.selectedDisplayedLabel = `${this.address.displayLabel[0]}`;
          } else if (this.address.name) {
            this.address.selectedDisplayedLabel = `${this.address.name}`;
          } else if (this.address.relayPoint) {
            this.address.selectedDisplayedLabel = `${this.address.relayPoint.name}`;
          } else if (this.address.event) {
            this.address.selectedDisplayedLabel = `${this.address.displayLabel[0]}`;
          } else {
            this.address.selectedDisplayedLabel = `${this.address.displayLabel[0]}`;
          }
          this.entries.push(this.address);
        } 
      }
    }
  },
  methods: {
    changedAddress() {
      this.$emit("address-selected", this.address);
    },
    getAsyncData: debounce(function(val) {
      this.isLoading = true;

      this.cancelRequest(); // CANCEL PREVIOUS REQUEST
      this.cancelSource = axios.CancelToken.source();

      axios
        .get(`${this.url}${val}` + (this.token ? "&token=" + this.token : ""), {
          cancelToken: this.cancelSource.token
        })
        .then(res => {
          this.cancelSource = null;
          this.isLoading = false;

          let results = [];
          let resultsNamed = [];
          let resultsSig = [];
          let resultsRelayPoint = [];
          let resultsEvent = [];

          // Modify property displayLabel to be shown into the autocomplete field after selection
          let addresses = res.data["hydra:member"];
          // No Adresses return, we stop here
          if (!addresses.length) {
            return;
          }
          addresses.forEach((address, addressKey) => {
            addresses[addressKey].key = addressKey;
            addresses[addressKey].displayedLabel = `${address.displayLabel[0]}`;
            addresses[addressKey].displayedSecondLabel = `${address.displayLabel[1]}`;
            if (address.name) {
              addresses[addressKey].selectedDisplayedLabel = `${address.name}`;
            } else if (address.relayPoint) {
              addresses[addressKey].selectedDisplayedLabel = `${address.relayPoint.name}`;
            } else if (address.event) {
              addresses[addressKey].selectedDisplayedLabel = `${address.event.name}`;
            } else {
              addresses[addressKey].selectedDisplayedLabel = `${address.displayLabel[0]}`;
            }
          });

          addresses.forEach((address, addressKey) => {
            let addressLocality = address.addressLocality
              ? address.addressLocality
              : "";
            if (addressLocality) {
              // If there is no locality return, do not show them (region, department ..)
              if (address.name) {
                resultsNamed.push(address);
              } else if (address.relayPoint) {
                resultsRelayPoint.push(address);
              } else if (address.event) {
                resultsEvent.push(address);
              } else {
                resultsSig.push(address);
              }
            } 
          });

          if (resultsNamed.length>0) {
            resultsNamed.forEach((address) => {
              results.push(address);
            });
          }

          if (resultsSig.length>0) {
            resultsSig.forEach((address) => {
              results.push(address);
            });
          }

          if (resultsRelayPoint.length>0) {
            if (results.length>0) {
              results.push({'divider':'true'});
              results.push({'header':this.$t('relayPoints')});
            }
            resultsRelayPoint.forEach((address) => {
              results.push(address);
            });
          }

          if (resultsEvent.length>0) {
            if (results.length>0) {
              results.push({'divider':'true'});
              results.push({'header':this.$t('events')});
            }
            resultsEvent.forEach((address) => {
              results.push(address);
            });
          }

          // Set Data & show them
          if (this.isLoading) return; // Another request is fetching, we do not show the previous one
          this.entries = [...results];
        })
        .catch(err => {
          this.items = [];
          console.error(err);
        })
        .finally(() => (this.isLoading = false));
    }, 1000),

    cancelRequest() {
      if(this.cancelSource) {
        this.cancelSource.cancel('Start new search, stop active search');
      }
    }
  }
};
</script>